# Sora MCAPå¯¾å¿œæ©Ÿèƒ½ è¨­è¨ˆãƒ»å®Ÿè£…ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

## 1. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦

### 1.1 ç›®çš„

MCAPãƒ•ã‚¡ã‚¤ãƒ«ã®å†ç”Ÿã«ãŠã„ã¦ã€ãƒ•ã‚¡ã‚¤ãƒ«å›ºæœ‰ã®æœ€é©ãªæ‹¡å¼µæ©Ÿèƒ½ãƒ»ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆçµ„ã¿åˆã‚ã›ã‚’è‡ªå‹•æ¨å¥¨ã—ã€ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã«ã¯è©³ç´°ãªã‚¬ã‚¤ãƒ€ãƒ³ã‚¹ã‚’æä¾›ã™ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã™ã‚‹ã€‚

### 1.2 èª²é¡Œèªè­˜

- **ãƒ•ã‚¡ã‚¤ãƒ«ä¾å­˜ã®å•é¡Œ**: MCAPãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚ˆã£ã¦æœ€é©ãªæ‹¡å¼µæ©Ÿèƒ½ãƒ»ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆãŒç•°ãªã‚‹
- **ã‚¨ãƒ©ãƒ¼æƒ…å ±ä¸è¶³**: å†ç”Ÿå¤±æ•—æ™‚ã®åŸå› ç‰¹å®šãŒå›°é›£
- **è¨­å®šã®è¤‡é›‘ã•**: æ‰‹å‹•ã§ã®æœ€é©åŒ–ãŒéåŠ¹ç‡
- **ãƒŠãƒ¬ãƒƒã‚¸æ•£é€¸**: æˆåŠŸãƒ‘ã‚¿ãƒ¼ãƒ³ã®è“„ç©ãƒ»å…±æœ‰ãŒã§ãã¦ã„ãªã„

### 1.3 è§£æ±ºæ–¹é‡

1. **ã‚¹ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼ã‚¬ã‚¤ãƒ€ãƒ³ã‚¹**: å…·ä½“çš„ã§å®Ÿè¡Œå¯èƒ½ãªè§£æ±ºç­–ã‚’æ®µéšçš„æç¤º
2. **ãƒ•ã‚¡ã‚¤ãƒ«å›ºæœ‰ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«**: MCAPå›ºæœ‰ã®æœ€é©è¨­å®šã‚’è‡ªå‹•ä¿å­˜ãƒ»å¾©å…ƒ
3. **ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯å­¦ç¿’**: åŒ¿ååŒ–ã•ã‚ŒãŸä½¿ç”¨ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æœ€é©ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å­¦ç¿’
4. **ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼é‡è¦–**: æ©Ÿå¯†æƒ…å ±ã‚’å«ã¾ãªã„åŒ¿ååŒ–ãƒ•ã‚£ãƒ³ã‚¬ãƒ¼ãƒ—ãƒªãƒ³ãƒˆ

## 2. ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ

### 2.1 ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“æ§‹æˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Sora Client (Electron)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  MCAP Analysis  â”‚  Profile Manager  â”‚  Error Handler      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚Fingerprint  â”‚ â”‚  â”‚Local Storage â”‚ â”‚  â”‚Smart Guidance   â”‚ â”‚
â”‚  â”‚Generator    â”‚ â”‚  â”‚Profile Cache â”‚ â”‚  â”‚Auto Recovery    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                 Extension & Layout System                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Multi-Version Extension Loader (sora-local)           â”‚ â”‚
â”‚  â”‚  Layout Marketplace Loader (sora-marketplace)          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â”‚ HTTPS (åŒ¿ååŒ–ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯)
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Lightweight Server                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Feedback API   â”‚  Recommendation  â”‚  Static File Server   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚POST feedbackâ”‚ â”‚  â”‚GET recommend â”‚ â”‚  â”‚Extensions .foxe â”‚ â”‚
â”‚  â”‚Validation   â”‚ â”‚  â”‚Pattern Match â”‚ â”‚  â”‚Layouts .json    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    SQLite Database                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  feedback_data  â”‚  recommendations  â”‚  statistics      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè²¬å‹™

#### ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´

- **MCAP Analysis**: ãƒ•ã‚¡ã‚¤ãƒ«è§£æãƒ»ãƒ•ã‚£ãƒ³ã‚¬ãƒ¼ãƒ—ãƒªãƒ³ãƒˆç”Ÿæˆ
- **Profile Manager**: ãƒ­ãƒ¼ã‚«ãƒ«è¨­å®šä¿å­˜ãƒ»å¾©å…ƒ
- **Error Handler**: ã‚¨ãƒ©ãƒ¼æ¤œå‡ºãƒ»è‡ªå‹•å¾©æ—§ãƒ»ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¬ã‚¤ãƒ€ãƒ³ã‚¹
- **Extension System**: æ—¢å­˜ã®Soraæ‹¡å¼µæ©Ÿèƒ½ã‚·ã‚¹ãƒ†ãƒ ã¨ã®çµ±åˆ

#### ã‚µãƒ¼ãƒãƒ¼å´

- **Feedback API**: åŒ¿ååŒ–ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã®å—ä¿¡ãƒ»æ¤œè¨¼
- **Recommendation Engine**: ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ãƒ»æ¨å¥¨ç”Ÿæˆ
- **File Server**: æ‹¡å¼µæ©Ÿèƒ½ãƒ»ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®é…ä¿¡

## 3. è©³ç´°è¨­è¨ˆ

### 3.1 MCAP ãƒ•ã‚£ãƒ³ã‚¬ãƒ¼ãƒ—ãƒªãƒ³ãƒˆ ã‚·ã‚¹ãƒ†ãƒ 

#### 3.1.1 åŒ¿ååŒ–ãƒ•ã‚£ãƒ³ã‚¬ãƒ¼ãƒ—ãƒªãƒ³ãƒˆ

```typescript
interface MCAPFingerprint {
  // æ§‹é€ çš„ç‰¹å¾´ï¼ˆãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼å®‰å…¨ï¼‰
  topicStructureHash: string; // ãƒˆãƒ”ãƒƒã‚¯æ§‹é€ ã®ãƒãƒƒã‚·ãƒ¥
  messageTypePattern: string; // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¿ã‚¤ãƒ—çµ„ã¿åˆã‚ã›ãƒ‘ã‚¿ãƒ¼ãƒ³
  frequencyProfile: string; // ãƒ‡ãƒ¼ã‚¿é »åº¦ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆã‚«ãƒ†ã‚´ãƒªåŒ–ï¼‰
  durationCategory: "short" | "medium" | "long";
  sizeCategory: "small" | "medium" | "large";
  complexityScore: number; // 0-100ã®è¤‡é›‘åº¦ã‚¹ã‚³ã‚¢

  // æ©Ÿèƒ½è¦æ±‚ã®æ¨å®š
  requiresVisualization: boolean;
  requires3D: boolean;
  requiresMapping: boolean;
  requiresPointCloud: boolean;

  // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ï¼ˆéè­˜åˆ¥ï¼‰
  version: string; // ãƒ•ã‚£ãƒ³ã‚¬ãƒ¼ãƒ—ãƒªãƒ³ãƒˆä»•æ§˜ãƒãƒ¼ã‚¸ãƒ§ãƒ³
  generatedAt: number; // ç”Ÿæˆã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ï¼ˆã‚¨ãƒãƒƒã‚¯ï¼‰
}

class MCAPFingerprintGenerator {
  constructor(private config: FingerprintConfig) {}

  async generateFingerprint(mcapFile: string): Promise<MCAPFingerprint> {
    const metadata = await this.extractMetadata(mcapFile);

    return {
      topicStructureHash: await this.hashTopicStructure(metadata.topics),
      messageTypePattern: this.analyzeMessageTypes(metadata.messageTypes),
      frequencyProfile: this.categorizeFrequencies(metadata.frequencies),
      durationCategory: this.categorizeDuration(metadata.duration),
      sizeCategory: this.categorizeSize(metadata.size),
      complexityScore: this.calculateComplexity(metadata),

      requiresVisualization: this.detectVisualizationNeeds(metadata),
      requires3D: this.detect3DNeeds(metadata),
      requiresMapping: this.detectMappingNeeds(metadata),
      requiresPointCloud: this.detectPointCloudNeeds(metadata),

      version: "1.0.0",
      generatedAt: Date.now(),
    };
  }

  private async hashTopicStructure(topics: string[]): Promise<string> {
    // ãƒˆãƒ”ãƒƒã‚¯åã‚’æŠ½è±¡ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¤‰æ›
    const patterns = topics.map(this.abstractTopicName);
    const sortedPatterns = patterns.sort();

    // SHA-256ã§ãƒãƒƒã‚·ãƒ¥åŒ–
    const encoder = new TextEncoder();
    const data = encoder.encode(sortedPatterns.join("|"));
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));

    return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  }

  private abstractTopicName(topic: string): string {
    // å…·ä½“çš„ãªåå‰ã‚’æŠ½è±¡ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¤‰æ›
    if (/\/camera.*\/image/.test(topic)) return "CAMERA_IMAGE";
    if (/\/lidar.*\/points/.test(topic)) return "LIDAR_POINTS";
    if (/\/nav.*\/path/.test(topic)) return "NAVIGATION_PATH";
    if (/\/tf/.test(topic)) return "TRANSFORM";
    if (/\/odom/.test(topic)) return "ODOMETRY";
    // ... ä»–ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
    return "GENERIC_TOPIC";
  }

  private detectVisualizationNeeds(metadata: MCAPMetadata): boolean {
    const visualizationTopics = ["CAMERA_IMAGE", "LIDAR_POINTS", "LASER_SCAN", "MARKER_ARRAY"];
    return metadata.abstractTopics.some((topic) => visualizationTopics.includes(topic));
  }

  private detect3DNeeds(metadata: MCAPMetadata): boolean {
    const threeDTopics = ["LIDAR_POINTS", "POINT_CLOUD", "MESH", "MARKER_3D"];
    return metadata.abstractTopics.some((topic) => threeDTopics.includes(topic));
  }
}
```

#### 3.1.2 ãƒ•ã‚£ãƒ³ã‚¬ãƒ¼ãƒ—ãƒªãƒ³ãƒˆç²¾åº¦å‘ä¸Š

```typescript
interface FingerprintSimilarity {
  exactMatch: boolean;
  similarityScore: number; // 0-1
  matchingFeatures: string[];
  differingFeatures: string[];
}

class FingerprintMatcher {
  calculateSimilarity(fp1: MCAPFingerprint, fp2: MCAPFingerprint): FingerprintSimilarity {
    let score = 0;
    let totalWeight = 0;
    const matching: string[] = [];
    const differing: string[] = [];

    // é‡è¦åº¦ã«ã‚ˆã‚‹é‡ã¿ä»˜ã‘
    const weights = {
      topicStructureHash: 0.4, // æœ€é‡è¦
      messageTypePattern: 0.3, // é‡è¦
      complexityScore: 0.2, // ä¸­ç¨‹åº¦
      requiresVisualization: 0.05,
      requires3D: 0.05,
    };

    // ãƒãƒƒã‚·ãƒ¥å®Œå…¨ä¸€è‡´
    if (fp1.topicStructureHash === fp2.topicStructureHash) {
      score += weights.topicStructureHash;
      matching.push("topicStructure");
    } else {
      differing.push("topicStructure");
    }
    totalWeight += weights.topicStructureHash;

    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¿ã‚¤ãƒ—ãƒ‘ã‚¿ãƒ¼ãƒ³
    if (fp1.messageTypePattern === fp2.messageTypePattern) {
      score += weights.messageTypePattern;
      matching.push("messageTypes");
    } else {
      differing.push("messageTypes");
    }
    totalWeight += weights.messageTypePattern;

    // è¤‡é›‘åº¦ã‚¹ã‚³ã‚¢ï¼ˆè¿‘ä¼¼ä¸€è‡´ï¼‰
    const complexityDiff = Math.abs(fp1.complexityScore - fp2.complexityScore);
    const complexitySimilarity = Math.max(0, 1 - complexityDiff / 100);
    score += weights.complexityScore * complexitySimilarity;
    totalWeight += weights.complexityScore;

    if (complexitySimilarity > 0.8) {
      matching.push("complexity");
    } else {
      differing.push("complexity");
    }

    // æ©Ÿèƒ½è¦æ±‚
    if (fp1.requiresVisualization === fp2.requiresVisualization) {
      score += weights.requiresVisualization;
      matching.push("visualization");
    } else {
      differing.push("visualization");
    }
    totalWeight += weights.requiresVisualization;

    if (fp1.requires3D === fp2.requires3D) {
      score += weights.requires3D;
      matching.push("3d");
    } else {
      differing.push("3d");
    }
    totalWeight += weights.requires3D;

    const finalScore = score / totalWeight;

    return {
      exactMatch: finalScore === 1.0,
      similarityScore: finalScore,
      matchingFeatures: matching,
      differingFeatures: differing,
    };
  }
}
```

### 3.2 ãƒ•ã‚¡ã‚¤ãƒ«å›ºæœ‰ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ« ã‚·ã‚¹ãƒ†ãƒ 

#### 3.2.1 ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«æ§‹é€ 

```typescript
interface MCAPProfile {
  // è­˜åˆ¥æƒ…å ±
  id: string; // UUID
  fingerprint: MCAPFingerprint; // ãƒ•ã‚¡ã‚¤ãƒ«ç‰¹å¾´
  fileHash?: string; // ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒã‚·ãƒ¥ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰

  // è¨­å®šæƒ…å ±
  configuration: PlaybackConfiguration;

  // ä½¿ç”¨çµ±è¨ˆ
  usage: ProfileUsageStats;

  // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
  metadata: ProfileMetadata;
}

interface PlaybackConfiguration {
  extensions: Array<{
    baseId: string;
    version: string;
    enabled: boolean;
    config?: Record<string, any>; // æ‹¡å¼µæ©Ÿèƒ½å›ºæœ‰è¨­å®š
  }>;

  layout: {
    baseId: string;
    version: string;
    customizations?: Record<string, any>;
  };

  playbackSettings: {
    speed: number;
    loop: boolean;
    timeRange?: [number, number];
    selectedTopics?: string[];
  };

  displaySettings: {
    theme: string;
    panelLayout?: any;
    viewerConfigs?: Record<string, any>;
  };
}

interface ProfileUsageStats {
  created: Date;
  lastUsed: Date;
  useCount: number;
  successRate: number; // 0-1
  averageLoadTime: number; // ãƒŸãƒªç§’
  errorHistory: Array<{
    timestamp: Date;
    errorType: string;
    resolved: boolean;
  }>;
}

interface ProfileMetadata {
  name?: string; // ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©å
  description?: string; // ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©èª¬æ˜
  tags?: string[]; // ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©ã‚¿ã‚°
  isShared: boolean; // ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£å…±æœ‰ãƒ•ãƒ©ã‚°
  sourceType: "auto" | "manual" | "imported";
  version: string; // ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ä»•æ§˜ãƒãƒ¼ã‚¸ãƒ§ãƒ³
}
```

#### 3.2.2 ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

```typescript
class MCAPProfileManager {
  private storage: IDBProfileStorage;
  private fingerprintGenerator: MCAPFingerprintGenerator;

  constructor() {
    this.storage = new IDBProfileStorage();
    this.fingerprintGenerator = new MCAPFingerprintGenerator();
  }

  async getProfileForFile(filePath: string): Promise<MCAPProfile | undefined> {
    // 1. ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒã‚·ãƒ¥ã«ã‚ˆã‚‹å®Œå…¨ä¸€è‡´æ¤œç´¢
    const fileHash = await this.calculateFileHash(filePath);
    let profile = await this.storage.getByFileHash(fileHash);

    if (profile) {
      await this.updateLastUsed(profile.id);
      return profile;
    }

    // 2. ãƒ•ã‚£ãƒ³ã‚¬ãƒ¼ãƒ—ãƒªãƒ³ãƒˆã«ã‚ˆã‚‹é¡ä¼¼æ¤œç´¢
    const fingerprint = await this.fingerprintGenerator.generateFingerprint(filePath);
    const similarProfiles = await this.findSimilarProfiles(fingerprint);

    if (similarProfiles.length > 0) {
      // æœ€ã‚‚é¡ä¼¼åº¦ã®é«˜ã„ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿”ã™
      const bestMatch = similarProfiles[0];

      // æ–°ã—ã„ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ä¿å­˜ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒã‚·ãƒ¥ä»˜ãï¼‰
      const newProfile = await this.createProfileFromTemplate(
        bestMatch.profile,
        fingerprint,
        fileHash,
      );

      return newProfile;
    }

    return undefined;
  }

  async saveProfile(
    filePath: string,
    configuration: PlaybackConfiguration,
    metadata: Partial<ProfileMetadata> = {},
  ): Promise<MCAPProfile> {
    const fingerprint = await this.fingerprintGenerator.generateFingerprint(filePath);
    const fileHash = await this.calculateFileHash(filePath);

    const profile: MCAPProfile = {
      id: crypto.randomUUID(),
      fingerprint,
      fileHash,
      configuration,
      usage: {
        created: new Date(),
        lastUsed: new Date(),
        useCount: 1,
        successRate: 1.0,
        averageLoadTime: 0,
        errorHistory: [],
      },
      metadata: {
        isShared: false,
        sourceType: "manual",
        version: "1.0.0",
        ...metadata,
      },
    };

    await this.storage.save(profile);
    return profile;
  }

  async updateProfileUsage(profileId: string, result: PlaybackResult): Promise<void> {
    const profile = await this.storage.getById(profileId);
    if (!profile) return;

    // ä½¿ç”¨çµ±è¨ˆæ›´æ–°
    profile.usage.lastUsed = new Date();
    profile.usage.useCount++;

    // æˆåŠŸç‡è¨ˆç®—
    const wasSuccessful = result.success && result.errorCount === 0;
    const totalAttempts = profile.usage.useCount;
    const previousSuccesses = Math.round(profile.usage.successRate * (totalAttempts - 1));
    const currentSuccesses = previousSuccesses + (wasSuccessful ? 1 : 0);
    profile.usage.successRate = currentSuccesses / totalAttempts;

    // ã‚¨ãƒ©ãƒ¼è¨˜éŒ²
    if (!wasSuccessful) {
      profile.usage.errorHistory.push({
        timestamp: new Date(),
        errorType: result.primaryErrorType || "unknown",
        resolved: false,
      });

      // ã‚¨ãƒ©ãƒ¼å±¥æ­´ã®åˆ¶é™ï¼ˆæœ€æ–°100ä»¶ã¾ã§ï¼‰
      if (profile.usage.errorHistory.length > 100) {
        profile.usage.errorHistory = profile.usage.errorHistory.slice(-100);
      }
    }

    await this.storage.save(profile);
  }

  private async findSimilarProfiles(
    fingerprint: MCAPFingerprint,
    threshold: number = 0.7,
  ): Promise<Array<{ profile: MCAPProfile; similarity: FingerprintSimilarity }>> {
    const allProfiles = await this.storage.getAll();
    const matcher = new FingerprintMatcher();
    const similarities: Array<{ profile: MCAPProfile; similarity: FingerprintSimilarity }> = [];

    for (const profile of allProfiles) {
      const similarity = matcher.calculateSimilarity(fingerprint, profile.fingerprint);

      if (similarity.similarityScore >= threshold) {
        similarities.push({ profile, similarity });
      }
    }

    // é¡ä¼¼åº¦ã§ã‚½ãƒ¼ãƒˆ
    similarities.sort((a, b) => b.similarity.similarityScore - a.similarity.similarityScore);

    return similarities;
  }

  private async createProfileFromTemplate(
    template: MCAPProfile,
    newFingerprint: MCAPFingerprint,
    fileHash: string,
  ): Promise<MCAPProfile> {
    const newProfile: MCAPProfile = {
      id: crypto.randomUUID(),
      fingerprint: newFingerprint,
      fileHash,
      configuration: { ...template.configuration },
      usage: {
        created: new Date(),
        lastUsed: new Date(),
        useCount: 1,
        successRate: template.usage.successRate, // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®æˆåŠŸç‡ã‚’ç¶™æ‰¿
        averageLoadTime: 0,
        errorHistory: [],
      },
      metadata: {
        ...template.metadata,
        sourceType: "auto",
        name: `Auto-generated from ${template.metadata.name || "similar profile"}`,
      },
    };

    await this.storage.save(newProfile);
    return newProfile;
  }
}
```

### 3.3 ã‚¹ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼ã‚¬ã‚¤ãƒ€ãƒ³ã‚¹ ã‚·ã‚¹ãƒ†ãƒ 

#### 3.3.1 ã‚¨ãƒ©ãƒ¼åˆ†æã‚¨ãƒ³ã‚¸ãƒ³

```typescript
interface PlaybackError {
  type: string;
  message: string;
  context: {
    topic?: string;
    messageType?: string;
    timestamp?: number;
    extensionId?: string;
  };
  severity: "low" | "medium" | "high" | "critical";
  count: number;
}

interface ErrorGuidance {
  problemType: ErrorProblemType;
  confidence: number; // 0-1
  rootCause: string;
  userFriendlyExplanation: string;
  automaticFixAvailable: boolean;
  solutions: SolutionStep[];
  preventionTips?: string[];
}

interface SolutionStep {
  id: string;
  title: string;
  description: string;
  type: "automatic" | "manual" | "download" | "configuration";
  estimatedTime: number; // ç§’
  riskLevel: "low" | "medium" | "high";
  prerequisites?: string[];
  action: () => Promise<SolutionResult>;
}

interface SolutionResult {
  success: boolean;
  message: string;
  nextSteps?: string[];
  rollbackAction?: () => Promise<void>;
}

type ErrorProblemType =
  | "missing_extension"
  | "version_mismatch"
  | "configuration_error"
  | "data_corruption"
  | "performance_issue"
  | "dependency_conflict"
  | "resource_limitation";

class SmartErrorAnalyzer {
  private extensionLoader: SoraExtensionLoader;
  private profileManager: MCAPProfileManager;

  constructor(extensionLoader: SoraExtensionLoader, profileManager: MCAPProfileManager) {
    this.extensionLoader = extensionLoader;
    this.profileManager = profileManager;
  }

  async analyzeError(error: PlaybackError, context: PlaybackContext): Promise<ErrorGuidance> {
    // ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸåˆ†æãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°
    switch (true) {
      case this.isMissingExtensionError(error):
        return await this.analyzeMissingExtension(error, context);

      case this.isVersionMismatchError(error):
        return await this.analyzeVersionMismatch(error, context);

      case this.isConfigurationError(error):
        return await this.analyzeConfigurationError(error, context);

      case this.isPerformanceIssue(error):
        return await this.analyzePerformanceIssue(error, context);

      default:
        return await this.analyzeGenericError(error, context);
    }
  }

  private async analyzeMissingExtension(
    error: PlaybackError,
    context: PlaybackContext,
  ): Promise<ErrorGuidance> {
    const messageType = error.context.messageType;
    const topicName = error.context.topic;

    // æ¨å¥¨æ‹¡å¼µæ©Ÿèƒ½ã®æ¤œç´¢
    const recommendations = await this.findExtensionsForMessageType(messageType);
    const alternatives = await this.findAlternativeExtensions(messageType);

    const solutions: SolutionStep[] = [];

    // 1. æ¨å¥¨æ‹¡å¼µæ©Ÿèƒ½ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
    for (const ext of recommendations) {
      solutions.push({
        id: `install_${ext.baseId}`,
        title: `${ext.displayName} ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«`,
        description: `${messageType} ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«æœ€é©åŒ–ã•ã‚ŒãŸæ‹¡å¼µæ©Ÿèƒ½ã§ã™ã€‚`,
        type: "download",
        estimatedTime: 30,
        riskLevel: "low",
        action: async () => {
          try {
            await this.extensionLoader.installExtensionFromMarketplace(ext.baseId);
            return {
              success: true,
              message: `${ext.displayName} ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãŒå®Œäº†ã—ã¾ã—ãŸã€‚`,
              nextSteps: ["å†ç”Ÿã‚’å†é–‹ã—ã¦ãã ã•ã„ã€‚"],
            };
          } catch (installError) {
            return {
              success: false,
              message: `ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã«å¤±æ•—ã—ã¾ã—ãŸ: ${installError.message}`,
            };
          }
        },
      });
    }

    // 2. ä»£æ›¿æ‹¡å¼µæ©Ÿèƒ½ã®ææ¡ˆ
    for (const alt of alternatives) {
      solutions.push({
        id: `try_alternative_${alt.baseId}`,
        title: `ä»£æ›¿æ‹¡å¼µæ©Ÿèƒ½: ${alt.displayName}`,
        description: `å®Œå…¨ãªäº’æ›æ€§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€åŸºæœ¬çš„ãªè¡¨ç¤ºãŒå¯èƒ½ã§ã™ã€‚`,
        type: "download",
        estimatedTime: 30,
        riskLevel: "medium",
        action: async () => {
          // ä»£æ›¿æ‹¡å¼µæ©Ÿèƒ½ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å‡¦ç†
          return { success: false, message: "Not implemented" };
        },
      });
    }

    // 3. æ‰‹å‹•è¨­å®šã®æ¡ˆå†…
    solutions.push({
      id: "manual_configuration",
      title: "æ‰‹å‹•ã§æ‹¡å¼µæ©Ÿèƒ½ã‚’æ¢ã™",
      description: "ãƒãƒ¼ã‚±ãƒƒãƒˆãƒ—ãƒ¬ã‚¤ã‚¹ã§é–¢é€£ã™ã‚‹æ‹¡å¼µæ©Ÿèƒ½ã‚’æ¤œç´¢ã—ã¾ã™ã€‚",
      type: "manual",
      estimatedTime: 300,
      riskLevel: "low",
      action: async () => {
        // æ‹¡å¼µæ©Ÿèƒ½è¨­å®šç”»é¢ã‚’é–‹ã
        return {
          success: true,
          message: "æ‹¡å¼µæ©Ÿèƒ½è¨­å®šç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚",
          nextSteps: [
            `ã€Œ${messageType}ã€ã§æ¤œç´¢ã—ã¦ãã ã•ã„ã€‚`,
            "é©åˆ‡ãªæ‹¡å¼µæ©Ÿèƒ½ã‚’è¦‹ã¤ã‘ã¦ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¦ãã ã•ã„ã€‚",
          ],
        };
      },
    });

    return {
      problemType: "missing_extension",
      confidence: 0.9,
      rootCause: `Message type "${messageType}" requires a visualization extension`,
      userFriendlyExplanation: `
        ã“ã®MCAPãƒ•ã‚¡ã‚¤ãƒ«ã«ã¯ã€Œ${messageType}ã€ã¨ã„ã†ã‚¿ã‚¤ãƒ—ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ãŒã€
        ãã‚Œã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã®æ‹¡å¼µæ©Ÿèƒ½ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚

        ãƒˆãƒ”ãƒƒã‚¯ã€Œ${topicName}ã€ã®ãƒ‡ãƒ¼ã‚¿ã‚’å¯è¦–åŒ–ã™ã‚‹ã«ã¯ã€å°‚ç”¨ã®æ‹¡å¼µæ©Ÿèƒ½ãŒå¿…è¦ã§ã™ã€‚
      `,
      automaticFixAvailable: recommendations.length > 0,
      solutions,
      preventionTips: [
        "MCAPãƒ•ã‚¡ã‚¤ãƒ«ã¨ä¸€ç·’ã«æ¨å¥¨æ‹¡å¼µæ©Ÿèƒ½ã®ãƒªã‚¹ãƒˆã‚’å…±æœ‰ã—ã¦ã‚‚ã‚‰ã†",
        "ãƒ•ã‚¡ã‚¤ãƒ«å›ºæœ‰ã®ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¦è¨­å®šã‚’ä¿å­˜ã™ã‚‹",
        "å®šæœŸçš„ã«æ‹¡å¼µæ©Ÿèƒ½ã‚’æœ€æ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«æ›´æ–°ã™ã‚‹",
      ],
    };
  }

  private async analyzeVersionMismatch(
    error: PlaybackError,
    context: PlaybackContext,
  ): Promise<ErrorGuidance> {
    const extensionId = error.context.extensionId!;
    const currentVersion = await this.getCurrentExtensionVersion(extensionId);
    const compatibleVersions = await this.getCompatibleVersions(extensionId, context);

    const solutions: SolutionStep[] = [];

    // äº’æ›ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¸ã®åˆ‡ã‚Šæ›¿ãˆ
    for (const version of compatibleVersions) {
      const isInstalled = await this.extensionLoader.isVersionInstalled(extensionId, version);

      if (isInstalled) {
        solutions.push({
          id: `switch_to_${version}`,
          title: `ãƒãƒ¼ã‚¸ãƒ§ãƒ³ ${version} ã«åˆ‡ã‚Šæ›¿ãˆ`,
          description: "æ—¢ã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆã¾ã™ã€‚",
          type: "automatic",
          estimatedTime: 5,
          riskLevel: "low",
          action: async () => {
            await this.extensionLoader.setActiveVersion(extensionId, version);
            return {
              success: true,
              message: `ãƒãƒ¼ã‚¸ãƒ§ãƒ³ ${version} ã«åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸã€‚`,
              rollbackAction: async () => {
                await this.extensionLoader.setActiveVersion(extensionId, currentVersion);
              },
            };
          },
        });
      } else {
        solutions.push({
          id: `install_${version}`,
          title: `ãƒãƒ¼ã‚¸ãƒ§ãƒ³ ${version} ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰`,
          description: "äº’æ›æ€§ã®ã‚ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™ã€‚",
          type: "download",
          estimatedTime: 30,
          riskLevel: "low",
          action: async () => {
            await this.extensionLoader.installSpecificVersion(extensionId, version);
            await this.extensionLoader.setActiveVersion(extensionId, version);
            return {
              success: true,
              message: `ãƒãƒ¼ã‚¸ãƒ§ãƒ³ ${version} ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã—ãŸã€‚`,
            };
          },
        });
      }
    }

    return {
      problemType: "version_mismatch",
      confidence: 0.95,
      rootCause: `Extension version incompatibility: ${currentVersion}`,
      userFriendlyExplanation: `
        æ‹¡å¼µæ©Ÿèƒ½ã€Œ${extensionId}ã€ã®ç¾åœ¨ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ï¼ˆ${currentVersion}ï¼‰ãŒã€
        ã“ã®MCAPãƒ•ã‚¡ã‚¤ãƒ«ã¨äº’æ›æ€§ãŒã‚ã‚Šã¾ã›ã‚“ã€‚

        ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ç‰¹å®šã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ä½œæˆã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’å«ã‚“ã§ã„ã‚‹ãŸã‚ã€
        äº’æ›æ€§ã®ã‚ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒå¿…è¦ã§ã™ã€‚
      `,
      automaticFixAvailable: true,
      solutions,
      preventionTips: [
        "è¤‡æ•°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä¸¦åˆ—ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¦ãŠã",
        "MCAPãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆæ™‚ã«ä½¿ç”¨ã—ãŸæ‹¡å¼µæ©Ÿèƒ½ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’è¨˜éŒ²ã™ã‚‹",
        "ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«æ©Ÿèƒ½ã‚’ä½¿ç”¨ã—ã¦è¨­å®šã‚’è‡ªå‹•ä¿å­˜ã™ã‚‹",
      ],
    };
  }
}
```

#### 3.3.2 è‡ªå‹•å¾©æ—§ã‚·ã‚¹ãƒ†ãƒ 

```typescript
class AutoRecoverySystem {
  private analyzer: SmartErrorAnalyzer;
  private maxRecoveryAttempts = 3;

  async handlePlaybackError(
    error: PlaybackError,
    context: PlaybackContext,
  ): Promise<RecoveryResult> {
    const guidance = await this.analyzer.analyzeError(error, context);

    if (!guidance.automaticFixAvailable) {
      return {
        success: false,
        guidance,
        message: "è‡ªå‹•å¾©æ—§ã§ãã¾ã›ã‚“ã€‚æ‰‹å‹•ã§ã®å¯¾å¿œãŒå¿…è¦ã§ã™ã€‚",
      };
    }

    // è‡ªå‹•å¾©æ—§ã®å®Ÿè¡Œ
    for (let attempt = 1; attempt <= this.maxRecoveryAttempts; attempt++) {
      const result = await this.executeAutoFix(guidance, attempt);

      if (result.success) {
        return {
          success: true,
          guidance,
          message: `è‡ªå‹•å¾©æ—§ãŒæˆåŠŸã—ã¾ã—ãŸï¼ˆè©¦è¡Œå›æ•°: ${attempt}/${this.maxRecoveryAttempts}ï¼‰`,
          appliedFix: result.appliedFix,
        };
      }

      // æ¬¡ã®è©¦è¡Œå‰ã«å°‘ã—å¾…æ©Ÿ
      if (attempt < this.maxRecoveryAttempts) {
        await this.delay(1000 * attempt); // æŒ‡æ•°çš„ãƒãƒƒã‚¯ã‚ªãƒ•
      }
    }

    return {
      success: false,
      guidance,
      message: `è‡ªå‹•å¾©æ—§ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆ${this.maxRecoveryAttempts}å›è©¦è¡Œï¼‰`,
    };
  }

  private async executeAutoFix(
    guidance: ErrorGuidance,
    attempt: number,
  ): Promise<{ success: boolean; appliedFix?: string }> {
    // ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ«ã®ä½ã„ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ã‹ã‚‰é †ã«è©¦è¡Œ
    const safeSolutions = guidance.solutions
      .filter((sol) => sol.type === "automatic" && sol.riskLevel === "low")
      .sort((a, b) => a.estimatedTime - b.estimatedTime); // æ™‚é–“ã®çŸ­ã„é †

    for (const solution of safeSolutions) {
      try {
        log.info(`Auto-recovery attempt ${attempt}: executing ${solution.id}`);

        const result = await solution.action();

        if (result.success) {
          return { success: true, appliedFix: solution.id };
        }

        log.warn(`Auto-recovery solution ${solution.id} failed: ${result.message}`);
      } catch (error) {
        log.error(`Auto-recovery solution ${solution.id} threw error:`, error);
      }
    }

    return { success: false };
  }

  private delay(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}

interface RecoveryResult {
  success: boolean;
  guidance: ErrorGuidance;
  message: string;
  appliedFix?: string;
}
```

### 3.4 ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯å­¦ç¿’ã‚·ã‚¹ãƒ†ãƒ 

#### 3.4.1 ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿æ§‹é€ 

```typescript
interface PlaybackFeedback {
  // è­˜åˆ¥æƒ…å ±ï¼ˆåŒ¿ååŒ–æ¸ˆã¿ï¼‰
  sessionId: string; // ã‚»ãƒƒã‚·ãƒ§ãƒ³å›ºæœ‰IDï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰
  fingerprint: MCAPFingerprint; // ãƒ•ã‚¡ã‚¤ãƒ«ç‰¹å¾´

  // è¨­å®šæƒ…å ±
  configuration: PlaybackConfiguration;

  // çµæœæƒ…å ±
  result: PlaybackResult;

  // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
  timestamp: number; // ã‚¨ãƒãƒƒã‚¯æ™‚é–“
  soraVersion: string;
  platform: "web" | "desktop";

  // ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ä¿è­·ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
  // - ãƒ•ã‚¡ã‚¤ãƒ«åã€ãƒ‘ã‚¹
  // - ãƒ¦ãƒ¼ã‚¶ãƒ¼è­˜åˆ¥æƒ…å ±
  // - å…·ä½“çš„ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
  // - ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ï¼ˆç›¸å¯¾æ™‚é–“ã®ã¿ï¼‰
}

interface PlaybackResult {
  success: boolean;
  playbackDuration: number; // æˆåŠŸã—ãŸå†ç”Ÿæ™‚é–“ï¼ˆç§’ï¼‰
  totalErrors: number;
  totalWarnings: number;

  performance: {
    averageFPS: number;
    peakMemoryMB: number;
    averageCPUPercent: number;
    loadTimeMs: number;
  };

  errorSummary: Array<{
    type: string; // æ±ç”¨åŒ–ã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—
    count: number;
    severity: "low" | "medium" | "high" | "critical";
  }>;

  // æ©Ÿèƒ½ä½¿ç”¨çŠ¶æ³
  featuresUsed: {
    visualizationPanels: string[];
    exportedData: boolean;
    customConfiguration: boolean;
  };
}

class FeedbackCollector {
  private isEnabled: boolean = false;
  private consent: FeedbackConsent | null = null;

  async initialize(): Promise<void> {
    this.consent = await this.loadConsentSettings();
    this.isEnabled = this.consent?.feedbackEnabled ?? false;

    if (!this.consent) {
      this.isEnabled = await this.requestUserConsent();
    }
  }

  async collectPlaybackFeedback(
    fingerprint: MCAPFingerprint,
    configuration: PlaybackConfiguration,
    result: PlaybackResult,
  ): Promise<void> {
    if (!this.isEnabled) return;

    const feedback: PlaybackFeedback = {
      sessionId: crypto.randomUUID(),
      fingerprint: this.sanitizeFingerprint(fingerprint),
      configuration: this.sanitizeConfiguration(configuration),
      result: this.sanitizeResult(result),
      timestamp: Date.now(),
      soraVersion: this.getSoraVersion(),
      platform: this.getPlatform(),
    };

    // ãƒ­ãƒ¼ã‚«ãƒ«ä¸€æ™‚ä¿å­˜ï¼ˆãƒãƒƒãƒé€ä¿¡ç”¨ï¼‰
    await this.storeLocalFeedback(feedback);

    // å®šæœŸé€ä¿¡ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
    this.scheduleBatchUpload();
  }

  private sanitizeConfiguration(config: PlaybackConfiguration): PlaybackConfiguration {
    return {
      extensions: config.extensions.map((ext) => ({
        baseId: ext.baseId,
        version: ext.version,
        enabled: ext.enabled,
        // config ã¯é™¤å»ï¼ˆæ©Ÿå¯†æƒ…å ±ã®å¯èƒ½æ€§ï¼‰
      })),
      layout: {
        baseId: config.layout.baseId,
        version: config.layout.version,
        // customizations ã¯é™¤å»
      },
      playbackSettings: {
        speed: config.playbackSettings.speed,
        loop: config.playbackSettings.loop,
        // timeRange, selectedTopics ã¯é™¤å»ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹æ¨æ¸¬å¯èƒ½ï¼‰
      },
      displaySettings: {
        theme: config.displaySettings.theme,
        // panelLayout, viewerConfigs ã¯é™¤å»
      },
    };
  }

  private sanitizeResult(result: PlaybackResult): PlaybackResult {
    return {
      ...result,
      errorSummary: result.errorSummary.map((error) => ({
        type: this.categorizeErrorType(error.type),
        count: error.count,
        severity: error.severity,
      })),
      // å…·ä½“çš„ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯é™¤å»æ¸ˆã¿
    };
  }

  private categorizeErrorType(errorType: string): string {
    // å…·ä½“çš„ãªã‚¨ãƒ©ãƒ¼ã‚’æ±ç”¨ã‚«ãƒ†ã‚´ãƒªã«åˆ†é¡
    if (errorType.includes("extension")) return "EXTENSION_ERROR";
    if (errorType.includes("decode")) return "DECODE_ERROR";
    if (errorType.includes("memory")) return "MEMORY_ERROR";
    if (errorType.includes("network")) return "NETWORK_ERROR";
    return "GENERIC_ERROR";
  }

  private async requestUserConsent(): Promise<boolean> {
    return new Promise((resolve) => {
      const dialog = new ConsentDialog({
        title: "ãƒ‡ãƒ¼ã‚¿å“è³ªå‘ä¸Šã¸ã®ã”å”åŠ›",
        content: `
          Soraã®å“è³ªå‘ä¸Šã®ãŸã‚ã€åŒ¿ååŒ–ã•ã‚ŒãŸä½¿ç”¨çŠ¶æ³ãƒ‡ãƒ¼ã‚¿ã®é€ä¿¡ã«ã”å”åŠ›ãã ã•ã„ã€‚

          ğŸ“Š é€ä¿¡ã•ã‚Œã‚‹æƒ…å ±:
          âœ… ãƒ•ã‚¡ã‚¤ãƒ«æ§‹é€ ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åãƒ»å†…å®¹ã¯å«ã¾ã‚Œã¾ã›ã‚“ï¼‰
          âœ… ä½¿ç”¨ã—ãŸæ‹¡å¼µæ©Ÿèƒ½ã®åå‰ã¨ãƒãƒ¼ã‚¸ãƒ§ãƒ³
          âœ… å†ç”Ÿã®æˆåŠŸãƒ»å¤±æ•—æƒ…å ±
          âœ… ã‚¨ãƒ©ãƒ¼ã®ç¨®é¡ï¼ˆå…·ä½“çš„ãªå†…å®¹ã¯å«ã¾ã‚Œã¾ã›ã‚“ï¼‰
          âœ… ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆ

          ğŸ”’ é€ä¿¡ã•ã‚Œãªã„æƒ…å ±:
          âŒ ãƒ•ã‚¡ã‚¤ãƒ«åãƒ»ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹
          âŒ ãƒ¦ãƒ¼ã‚¶ãƒ¼è­˜åˆ¥æƒ…å ±
          âŒ å…·ä½“çš„ãªè¨­å®šå€¤ãƒ»ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
          âŒ ä½ç½®æƒ…å ±ãƒ»å€‹äººãƒ‡ãƒ¼ã‚¿

          ã“ã®è¨­å®šã¯å¾Œã‹ã‚‰å¤‰æ›´ã§ãã¾ã™ã€‚
          è©³ç´°ãªãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ãƒãƒªã‚·ãƒ¼ã‚’ç¢ºèªã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚
        `,
        buttons: [
          {
            text: "å”åŠ›ã™ã‚‹",
            variant: "contained",
            onClick: () => resolve(true),
          },
          {
            text: "å”åŠ›ã—ãªã„",
            variant: "outlined",
            onClick: () => resolve(false),
          },
          {
            text: "è©³ç´°ã‚’ç¢ºèª",
            variant: "text",
            onClick: () => this.showPrivacyPolicy(),
          },
        ],
      });

      dialog.show();
    });
  }
}
```

#### 3.4.2 æ¨å¥¨ç”Ÿæˆã‚¨ãƒ³ã‚¸ãƒ³

```typescript
class RecommendationEngine {
  private database: FeedbackDatabase;
  private matcher: FingerprintMatcher;

  async generateRecommendations(
    fingerprint: MCAPFingerprint,
  ): Promise<ConfigurationRecommendation[]> {
    // 1. å®Œå…¨ä¸€è‡´æ¤œç´¢
    const exactMatches = await this.findExactMatches(fingerprint);

    if (exactMatches.length >= 3) {
      return this.analyzeExactMatches(exactMatches);
    }

    // 2. é«˜é¡ä¼¼åº¦æ¤œç´¢
    const similarMatches = await this.findSimilarMatches(fingerprint, 0.8);

    if (similarMatches.length >= 5) {
      return this.analyzeSimilarMatches(similarMatches);
    }

    // 3. ç‰¹å¾´ãƒ™ãƒ¼ã‚¹æ¤œç´¢
    const featureMatches = await this.findFeatureBasedMatches(fingerprint);

    if (featureMatches.length >= 10) {
      return this.analyzeFeatureMatches(featureMatches);
    }

    // 4. ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ¨å¥¨
    return this.getDefaultRecommendations(fingerprint);
  }

  private async analyzeExactMatches(
    matches: PlaybackFeedback[],
  ): Promise<ConfigurationRecommendation[]> {
    // æˆåŠŸç‡ã§ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
    const configGroups = this.groupByConfiguration(matches);
    const recommendations: ConfigurationRecommendation[] = [];

    for (const [configKey, feedbacks] of configGroups) {
      const successRate = this.calculateSuccessRate(feedbacks);
      const avgPerformance = this.calculateAveragePerformance(feedbacks);

      if (successRate >= 0.8) {
        // 80%ä»¥ä¸Šã®æˆåŠŸç‡
        recommendations.push({
          configuration: this.parseConfiguration(configKey),
          confidence: successRate,
          evidence: {
            sampleSize: feedbacks.length,
            successRate,
            averagePerformance: avgPerformance,
            recentUsage: this.calculateRecentUsage(feedbacks),
          },
          tags: this.generateRecommendationTags(feedbacks),
        });
      }
    }

    // ä¿¡é ¼åº¦ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã§ã‚½ãƒ¼ãƒˆ
    recommendations.sort((a, b) => {
      const scoreA = a.confidence * 0.6 + a.evidence.averagePerformance.score * 0.4;
      const scoreB = b.confidence * 0.6 + b.evidence.averagePerformance.score * 0.4;
      return scoreB - scoreA;
    });

    return recommendations.slice(0, 5); // ä¸Šä½5ä»¶
  }

  private groupByConfiguration(feedbacks: PlaybackFeedback[]): Map<string, PlaybackFeedback[]> {
    const groups = new Map<string, PlaybackFeedback[]>();

    for (const feedback of feedbacks) {
      const key = this.generateConfigurationKey(feedback.configuration);

      if (!groups.has(key)) {
        groups.set(key, []);
      }

      groups.get(key)!.push(feedback);
    }

    return groups;
  }

  private generateConfigurationKey(config: PlaybackConfiguration): string {
    // è¨­å®šã‚’æ­£è¦åŒ–ã—ã¦ã‚­ãƒ¼ã‚’ç”Ÿæˆ
    const extensionKeys = config.extensions
      .map((ext) => `${ext.baseId}@${ext.version}`)
      .sort()
      .join("|");

    const layoutKey = `${config.layout.baseId}@${config.layout.version}`;

    return `${extensionKeys}::${layoutKey}`;
  }

  private calculateSuccessRate(feedbacks: PlaybackFeedback[]): number {
    const successCount = feedbacks.filter((f) => f.result.success).length;
    return successCount / feedbacks.length;
  }

  private calculateAveragePerformance(feedbacks: PlaybackFeedback[]): PerformanceScore {
    const successfulFeedbacks = feedbacks.filter((f) => f.result.success);

    if (successfulFeedbacks.length === 0) {
      return { score: 0, details: {} };
    }

    const avgFPS = this.average(successfulFeedbacks.map((f) => f.result.performance.averageFPS));
    const avgMemory = this.average(
      successfulFeedbacks.map((f) => f.result.performance.peakMemoryMB),
    );
    const avgCPU = this.average(
      successfulFeedbacks.map((f) => f.result.performance.averageCPUPercent),
    );
    const avgLoadTime = this.average(
      successfulFeedbacks.map((f) => f.result.performance.loadTimeMs),
    );

    // æ­£è¦åŒ–ã‚¹ã‚³ã‚¢ï¼ˆ0-1ï¼‰
    const fpsScore = Math.min(avgFPS / 60, 1); // 60FPS ã‚’æœ€é«˜ã¨ã™ã‚‹
    const memoryScore = Math.max(0, 1 - avgMemory / 1000); // 1GB ã‚’åŸºæº–
    const cpuScore = Math.max(0, 1 - avgCPU / 100);
    const loadTimeScore = Math.max(0, 1 - avgLoadTime / 10000); // 10ç§’ã‚’åŸºæº–

    const overallScore = (fpsScore + memoryScore + cpuScore + loadTimeScore) / 4;

    return {
      score: overallScore,
      details: {
        averageFPS: avgFPS,
        averageMemoryMB: avgMemory,
        averageCPUPercent: avgCPU,
        averageLoadTimeMs: avgLoadTime,
      },
    };
  }

  private average(numbers: number[]): number {
    return numbers.reduce((sum, n) => sum + n, 0) / numbers.length;
  }
}

interface ConfigurationRecommendation {
  configuration: PlaybackConfiguration;
  confidence: number; // 0-1
  evidence: {
    sampleSize: number;
    successRate: number;
    averagePerformance: PerformanceScore;
    recentUsage: number; // æœ€è¿‘ã®ä½¿ç”¨é »åº¦
  };
  tags: string[]; // ["high-performance", "stable", "popular" ãªã©]
}

interface PerformanceScore {
  score: number; // 0-1ã®æ­£è¦åŒ–ã‚¹ã‚³ã‚¢
  details: {
    averageFPS: number;
    averageMemoryMB: number;
    averageCPUPercent: number;
    averageLoadTimeMs: number;
  };
}
```

## 4. å®Ÿè£…ãƒ•ã‚§ãƒ¼ã‚º

### Phase 1: åŸºç›¤ã‚·ã‚¹ãƒ†ãƒ  (2-3é€±é–“)

#### 4.1 å„ªå…ˆå®Ÿè£…é …ç›®

1. **MCAPFingerprintGenerator** - ãƒ•ã‚¡ã‚¤ãƒ«è§£æãƒ»åŒ¿ååŒ–
2. **MCAPProfileManager** - ãƒ­ãƒ¼ã‚«ãƒ«ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†
3. **SmartErrorAnalyzer** - åŸºæœ¬çš„ãªã‚¨ãƒ©ãƒ¼åˆ†æ
4. **FeedbackCollector** - ãƒ‡ãƒ¼ã‚¿åé›†ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜ã®ã¿ï¼‰

#### 4.2 æ¤œè¨¼é …ç›®

- ãƒ•ã‚£ãƒ³ã‚¬ãƒ¼ãƒ—ãƒªãƒ³ãƒˆã®ä¸€æ„æ€§ãƒ»åŒ¿åæ€§
- ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¿å­˜ãƒ»å¾©å…ƒ
- ã‚¨ãƒ©ãƒ¼åˆ†æã®ç²¾åº¦
- ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ä¿è­·ã®å¦¥å½“æ€§

### Phase 2: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ– (2é€±é–“)

#### 2.1 å®Ÿè£…é …ç›®

1. **AutoRecoverySystem** - è‡ªå‹•å¾©æ—§æ©Ÿèƒ½
2. **æ‹¡å¼µæ©Ÿèƒ½è‡ªå‹•ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«** - ãƒãƒ¼ã‚±ãƒƒãƒˆãƒ—ãƒ¬ã‚¤ã‚¹é€£æº
3. **ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¬ã‚¤ãƒ€ãƒ³ã‚¹UI** - ã‚¹ãƒ†ãƒƒãƒ—ãƒã‚¤ã‚¹ãƒ†ãƒƒãƒ—æ¡ˆå†…
4. **ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³æ‹¡å¼µ** - ã‚ˆã‚Šå¤šãã®ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—å¯¾å¿œ

### Phase 3: å­¦ç¿’ã‚·ã‚¹ãƒ†ãƒ  (2-3é€±é–“)

#### 3.1 å®Ÿè£…é …ç›®

1. **RecommendationEngine** - æ¨å¥¨ç”Ÿæˆ
2. **ã‚µãƒ¼ãƒãƒ¼é€£æº** - ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯é€ä¿¡ãƒ»æ¨å¥¨å–å¾—
3. **çµ±è¨ˆåˆ†æ** - ä½¿ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ
4. **A/Bãƒ†ã‚¹ãƒˆæ©Ÿèƒ½** - æ¨å¥¨ç²¾åº¦ã®æ¤œè¨¼

### Phase 4: æœ€é©åŒ–ãƒ»é‹ç”¨ (1-2é€±é–“)

#### 4.1 å®Ÿè£…é …ç›®

1. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–** - å¿œç­”æ™‚é–“æ”¹å–„
2. **ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£å‘ä¸Š** - UI/UXæ”¹å–„
3. **ç›£è¦–ãƒ»ãƒ­ã‚°** - é‹ç”¨ç›£è¦–æ©Ÿèƒ½
4. **ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ•´å‚™** - ãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘ã‚¬ã‚¤ãƒ‰

## 5. å“è³ªä¿è¨¼

### 5.1 ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ãƒ»ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

- [ ] ãƒ‡ãƒ¼ã‚¿åŒ¿ååŒ–ã®å¦¥å½“æ€§æ¤œè¨¼
- [ ] PIIé™¤å»ã®å®Œå…¨æ€§ç¢ºèª
- [ ] ãƒ•ã‚£ãƒ³ã‚¬ãƒ¼ãƒ—ãƒªãƒ³ãƒˆé€†ç®—ä¸å¯èƒ½æ€§ã®æ¤œè¨¼
- [ ] GDPR/å„å›½ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼æ³•æº–æ‹ ç¢ºèª

### 5.2 æ©Ÿèƒ½å“è³ª

- [ ] ã‚¨ãƒ©ãƒ¼æ¤œå‡ºç²¾åº¦: 90%ä»¥ä¸Š
- [ ] è‡ªå‹•å¾©æ—§æˆåŠŸç‡: 70%ä»¥ä¸Š
- [ ] æ¨å¥¨è¨­å®šç²¾åº¦: 80%ä»¥ä¸Š
- [ ] å¿œç­”æ™‚é–“: 500msä»¥ä¸‹

### 5.3 é‹ç”¨å“è³ª

- [ ] ã‚·ã‚¹ãƒ†ãƒ å¯ç”¨æ€§: 99.9%ä»¥ä¸Š
- [ ] ãƒ‡ãƒ¼ã‚¿æå¤±ã‚¼ãƒ­
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆã‚¼ãƒ­
- [ ] ãƒ¦ãƒ¼ã‚¶ãƒ¼æº€è¶³åº¦: 4.0/5.0ä»¥ä¸Š

## 6. æˆåŠŸæŒ‡æ¨™ (KPI)

### 6.1 æŠ€è¡“æŒ‡æ¨™

- **ã‚¨ãƒ©ãƒ¼è§£æ±ºç‡**: æ‰‹å‹•ä»‹å…¥ãªã—ã§ã®å•é¡Œè§£æ±ºç‡
- **è¨­å®šæ™‚é–“çŸ­ç¸®**: ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ä½¿ç”¨ã«ã‚ˆã‚‹è¨­å®šæ™‚é–“å‰Šæ¸›
- **å†ç”ŸæˆåŠŸç‡**: åˆå›å†ç”Ÿã§ã®æˆåŠŸç‡å‘ä¸Š

### 6.2 ãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡æ¨™

- **æ©Ÿèƒ½æ¡ç”¨ç‡**: MCAPå†ç”Ÿã§ã®ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ä½¿ç”¨ç‡
- **ã‚¨ãƒ©ãƒ¼æ¸›å°‘ç‡**: ãƒ¦ãƒ¼ã‚¶ãƒ¼å ±å‘Šã‚¨ãƒ©ãƒ¼ã®æ¸›å°‘
- **æº€è¶³åº¦**: æ©Ÿèƒ½ã«å¯¾ã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼è©•ä¾¡

---

**æ³¨æ„**: ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã¯ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ä¿è­·ã‚’æœ€å„ªå…ˆã¨ã—ã¦è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚å®Ÿè£…æ™‚ã«ã¯å¿…ãšãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼å½±éŸ¿è©•ä¾¡ã‚’å®Ÿæ–½ã—ã€é©åˆ‡ãªåŒæ„å–å¾—ãƒ—ãƒ­ã‚»ã‚¹ã‚’ç¢ºç«‹ã—ã¦ãã ã•ã„ã€‚

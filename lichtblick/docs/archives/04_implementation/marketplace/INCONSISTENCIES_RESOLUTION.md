# マーケットプレイス機能 仕様不整合対応方針書

> **作成日**: 2025年9月30日
> **対象**: マーケットプレイス機能の仕様不整合解消
> **ステータス**: 対応方針検討中
> **関連**: [MARKETPLACE_FEATURES.md](./MARKETPLACE_FEATURES.md)

---

## 📋 目次

1. [概要](#概要)
2. [不整合1: バージョン管理方式の移行期](#不整合1-バージョン管理方式の移行期)
3. [不整合2: 拡張機能IDの形式](#不整合2-拡張機能idの形式)
4. [不整合3: マーケットプレイスAPI仕様](#不整合3-マーケットプレイスapi仕様)
5. [不整合4: ExtensionSettingsの二重実装](#不整合4-extensionsettingsの二重実装)
6. [不整合5: VERSIONタブ機能](#不整合5-versionタブ機能)
7. [不整合6: LayoutDetails実装状況](#不整合6-layoutdetails実装状況)
8. [不整合7: テスト用サムネイル画像](#不整合7-テスト用サムネイル画像)
9. [推奨実装順序](#推奨実装順序)

---

## 概要

マーケットプレイス機能の開発において、ドキュメント間および実装との間で7つの不整合が確認されました。本ドキュメントでは、各不整合について以下を提示します:

- **現状分析**: 何が不整合なのか
- **影響範囲**: どの機能・コンポーネントに影響するか
- **対応選択肢**: 複数の解決策とその評価
- **推奨対応**: 最も適切と思われる対応
- **実装タスク**: 具体的な作業項目

---

## 不整合1: バージョン管理方式の移行期

### 📊 現状分析

**問題**:

- レガシー形式（単一バージョン）とマルチバージョン形式のデータ構造が混在
- ハイブリッドローダーで両方に対応しているが、完全移行計画が未確定
- 各ドキュメントで異なるバージョン管理方式を前提としている

**関連ドキュメント**:

- `hybrid-version-data-structure.md`: マルチバージョン対応の詳細設計
- `extension-requirements.md`: レガシー形式のAPI仕様
- `version-ui-plan.md`: 複数バージョンUI実装計画（未実装）

**現在の実装**:

- `HybridExtensionLoader`: 両方の形式を自動検出して変換
- `UnifiedExtensionData`: 統一された内部形式
- データ構造の自動判別と変換機能

### 🎯 影響範囲

- ✅ データ取得・変換ロジック
- ✅ ExtensionCatalogContext
- ✅ マーケットプレイスAPI設計
- ⚠️ 外部マーケットプレイスとの互換性
- ⚠️ 既存拡張機能の移行作業

### 💡 対応選択肢

#### 選択肢A: 現状維持（ハイブリッド方式継続）

**概要**: 現在のハイブリッドローダーを継続使用し、両方の形式を無期限サポート

**メリット**:

- ✅ 既存システムとの完全な互換性
- ✅ 追加実装が不要
- ✅ 外部マーケットプレイスとの柔軟な統合
- ✅ 段階的な移行が可能

**デメリット**:

- ❌ コードの複雑性が増す
- ❌ 保守コストが高い
- ❌ 新機能追加時に両方の形式を考慮する必要がある
- ❌ パフォーマンスオーバーヘッド（変換処理）

**工数**: 0人日（追加作業なし）

**リスク**: 低

---

#### 選択肢B: マルチバージョンへの完全移行（6ヶ月計画）

**概要**: 6ヶ月かけてレガシー形式を段階的に廃止し、マルチバージョン形式に統一

**フェーズ1（1-2ヶ月）**: 準備・移行ツール開発

- レガシー→マルチバージョン自動変換ツール開発
- 既存データの分析と移行計画策定
- 移行ドキュメント作成

**フェーズ2（3-4ヶ月）**: 段階的移行

- 新規拡張機能からマルチバージョン形式を必須化
- 既存拡張機能の順次変換（優先度順）
- 両形式の並行稼働（警告表示）

**フェーズ3（5-6ヶ月）**: レガシー形式廃止

- レガシー形式サポート終了アナウンス
- 未移行拡張機能の強制変換
- HybridExtensionLoaderのシンプル化

**メリット**:

- ✅ コードベースがシンプルになる
- ✅ 保守性が向上
- ✅ 新機能開発が容易になる
- ✅ パフォーマンス向上

**デメリット**:

- ❌ 移行作業のコストが高い
- ❌ 既存システムへの影響が大きい
- ❌ 外部マーケットプレイスとの互換性問題
- ❌ ユーザーへの影響（一時的な不具合の可能性）

**工数**: 30-40人日

**リスク**: 中〜高

---

#### 選択肢C: ハイブリッド方式の改善（推奨）

**概要**: ハイブリッド方式を継続しつつ、新規拡張機能はマルチバージョン形式を推奨

**実装内容**:

1. **新規拡張機能ガイドライン**: マルチバージョン形式を推奨
2. **変換ツール提供**: レガシー→マルチバージョン変換ツール
3. **パフォーマンス最適化**: HybridExtensionLoaderのキャッシュ強化
4. **ドキュメント統一**: 両形式のサポート状況を明記

**メリット**:

- ✅ 段階的な移行が可能
- ✅ 既存システムへの影響が少ない
- ✅ 柔軟性が高い
- ✅ パフォーマンス最適化により速度問題を解消

**デメリット**:

- ⚠️ 完全な統一には時間がかかる
- ⚠️ 一定の複雑性は残る

**工数**: 5-8人日

**リスク**: 低

---

### ✅ 推奨対応

**選択肢C: ハイブリッド方式の改善**

**理由**:

1. 既存システムへの影響を最小限に抑えられる
2. 段階的な移行により、リスクを分散できる
3. 実装コストと効果のバランスが良い
4. 外部マーケットプレイスとの互換性を維持できる

### 📝 実装タスク

| タスク                                  | 優先度 | 工数  | 担当 |
| --------------------------------------- | ------ | ----- | ---- |
| マルチバージョン形式ガイドライン作成    | 高     | 1日   | -    |
| レガシー→マルチバージョン変換ツール開発 | 高     | 2-3日 | -    |
| HybridExtensionLoaderのキャッシュ最適化 | 中     | 2日   | -    |
| ドキュメント統一・更新                  | 高     | 1-2日 | -    |
| テストケース追加                        | 中     | 1日   | -    |

**合計工数**: 7-9人日

---

## 不整合2: 拡張機能IDの形式

### 📊 現状分析

**問題**:

- 従来形式: `publisher.name`
- 計画中の形式: `publisher.name@version`
- 実装は従来形式のまま、移行計画のみ存在

**関連ドキュメント**:

- `versioned-extension-ids.md`: バージョン付きID実装の詳細
- `extension-version-migration-implementation-plan.md`: 段階的移行計画

**現在の実装**:

- ID形式: `publisher.name`
- 内部的にbaseIdとversionを分離して管理
- バージョン指定時は関数引数で渡す方式

### 🎯 影響範囲

- ✅ ExtensionCatalogContext
- ✅ ストレージキー
- ✅ インストール済み拡張機能の識別
- ⚠️ 既存の保存データとの互換性
- ⚠️ 外部システムとの連携

### 💡 対応選択肢

#### 選択肢A: 従来形式継続（推奨）

**概要**: `publisher.name`形式を継続し、バージョン管理は内部的に処理

**実装方針**:

- ID形式は変更しない
- バージョン情報は別フィールドで管理
- `generateVersionedId()`等のヘルパー関数で必要時のみ生成

**メリット**:

- ✅ 既存システムとの完全な互換性
- ✅ 移行作業不要
- ✅ シンプルなデータ構造
- ✅ 外部システムとの連携が容易

**デメリット**:

- ⚠️ バージョン別インストールの実装が複雑
- ⚠️ ID重複の可能性（同じbaseIdで複数バージョン）

**工数**: 0人日（追加作業なし）

**リスク**: 低

---

#### 選択肢B: バージョン付きIDへの完全移行

**概要**: `publisher.name@version`形式に完全移行し、既存データも変換

**フェーズ1**: データマイグレーション

- 既存ストレージデータの変換
- IndexedDBスキーマ更新
- ロールバック機能の実装

**フェーズ2**: コード更新

- ExtensionCatalogContextの更新
- ID生成・解析ロジックの変更
- 全コンポーネントでのID形式変更

**フェーズ3**: テスト・検証

- マイグレーション動作確認
- 互換性テスト
- パフォーマンステスト

**メリット**:

- ✅ バージョン別管理が明確
- ✅ ID重複の問題を根本解決
- ✅ 将来的な拡張が容易

**デメリット**:

- ❌ 大規模な移行作業が必要
- ❌ データ破損のリスク
- ❌ 既存拡張機能の動作に影響
- ❌ ロールバックが困難

**工数**: 15-20人日

**リスク**: 高

---

#### 選択肢C: ハイブリッドアプローチ

**概要**: 内部的には従来形式、必要時のみバージョン付きIDを使用

**実装内容**:

1. **baseId**: `publisher.name`（従来形式）
2. **versionedId**: `publisher.name@version`（内部使用のみ）
3. ヘルパー関数で相互変換

```typescript
// ID管理ヘルパー
function getBaseId(id: string): string;
function getVersionedId(baseId: string, version: string): string;
function parseVersionedId(versionedId: string): { baseId: string; version: string };
```

**メリット**:

- ✅ 柔軟性が高い
- ✅ 既存システムとの互換性維持
- ✅ 段階的な移行が可能
- ✅ 両方の利点を享受

**デメリット**:

- ⚠️ コードが複雑になる
- ⚠️ 一貫性が欠ける可能性

**工数**: 3-5人日

**リスク**: 低〜中

---

### ✅ 推奨対応

**選択肢A: 従来形式継続**

**理由**:

1. 現在の実装で十分機能している
2. バージョン管理は内部的に適切に処理されている
3. 移行のリスクとコストが見合わない
4. 必要に応じて選択肢Cに移行可能

**補足**:

- 複数バージョンの同時インストールが必要になった場合のみ、選択肢Cへの移行を検討

### 📝 実装タスク

| タスク                                                     | 優先度 | 工数  | 担当 |
| ---------------------------------------------------------- | ------ | ----- | ---- |
| 現在のID管理方針をドキュメント化                           | 高     | 0.5日 | -    |
| `versioned-extension-ids.md`を「将来の検討事項」として更新 | 中     | 0.5日 | -    |

**合計工数**: 1人日

---

## 不整合3: マーケットプレイスAPI仕様

### 📊 現状分析

**問題**:

- `extension-requirements.md`: 独立したGoサーバー + S3バケット構成を記載
- 実装: ExtensionCatalogContextを拡張した既存API活用

**要件定義書の仕様**:

```
Internet → Caddy Proxy → Web App (Port 3000)
                       → Marketplace Server (Go, Port 8080) → S3
```

**現在の実装**:

```
Web App → ExtensionCatalogContext → 既存API
```

### 🎯 影響範囲

- ✅ マーケットプレイスデータ取得
- ✅ 拡張機能ダウンロード
- ⚠️ インフラ構成
- ⚠️ 運用コスト
- ⚠️ スケーラビリティ

### 💡 対応選択肢

#### 選択肢A: 既存API継続使用（推奨）

**概要**: 現在の実装を継続し、ExtensionCatalogを拡張して使用

**実装方針**:

- ExtensionCatalogContextに必要な機能を追加
- 既存のローダー機構を活用
- フロントエンド主導のデータ管理

**メリット**:

- ✅ 追加インフラ不要
- ✅ 開発コストが低い
- ✅ 既存システムとの統合が容易
- ✅ デスクトップ/Web両対応が容易

**デメリット**:

- ❌ スケーラビリティに制限
- ❌ 高度な機能追加が困難
- ❌ CORS問題の可能性

**工数**: 0人日（追加作業なし）

**リスク**: 低

---

#### 選択肢B: 独立マーケットプレイスサーバー構築

**概要**: 要件定義書通りにGoサーバー + S3構成を実装

**アーキテクチャ**:

```
┌─────────────┐
│   Client    │
└──────┬──────┘
       │
┌──────▼──────────────────────────┐
│      Caddy Proxy Server         │
│      (your-domain.com)          │
└─────┬──────────────┬────────────┘
      │              │
┌─────▼─────┐  ┌────▼─────────────┐
│  Web App  │  │ Marketplace API  │
│ (Port 3000)│  │   (Go, 8080)    │
└───────────┘  └────┬─────────────┘
                    │
               ┌────▼─────┐
               │  AWS S3  │
               └──────────┘
```

**実装フェーズ**:

**フェーズ1（2-3週間）**: 基本API実装

- Goサーバー開発
- S3連携実装
- extensions.json配信
- .foxeファイル配信

**フェーズ2（1-2週間）**: 高度な機能

- バージョン管理API
- 検索API
- 統計API
- キャッシュ機構

**フェーズ3（1週間）**: インフラ構築

- AWS環境構築
- Caddyプロキシ設定
- CI/CD整備
- 監視・ログ設定

**メリット**:

- ✅ スケーラビリティが高い
- ✅ 高度な機能追加が容易
- ✅ フロントエンド負荷を軽減
- ✅ CDN活用でパフォーマンス向上
- ✅ マイクロサービス化

**デメリット**:

- ❌ 開発コストが高い
- ❌ インフラコスト（月額$15以上）
- ❌ 運用負荷が増加
- ❌ システム複雑化

**工数**: 20-30人日

**リスク**: 中〜高

---

#### 選択肢C: 段階的移行（ハイブリッド）

**概要**: 現在は既存API、将来的に独立サーバーへ段階的移行

**フェーズ1（現在）**: 既存API継続

- ExtensionCatalogContext使用
- 基本機能の安定化

**フェーズ2（3-6ヶ月後）**: 簡易APIサーバー

- 静的ファイル配信のみのシンプルなサーバー
- Vercel/Netlify等のサーバーレス活用
- 低コスト運用

**フェーズ3（6-12ヶ月後）**: フル機能サーバー

- Goサーバー実装
- 高度な機能追加
- 完全な独立化

**メリット**:

- ✅ リスク分散
- ✅ 段階的なコスト発生
- ✅ 学習曲線が緩やか
- ✅ 柔軟な軌道修正

**デメリット**:

- ⚠️ 長期的な開発期間
- ⚠️ アーキテクチャの複数回変更

**工数**:

- フェーズ1: 0人日
- フェーズ2: 5-8人日
- フェーズ3: 20-30人日

**リスク**: 低

---

### ✅ 推奨対応

**選択肢C: 段階的移行（ハイブリッド）**

**理由**:

1. 現時点では既存APIで十分機能している
2. ユーザー数・拡張機能数の増加に応じて拡張可能
3. リスクとコストを最小限に抑えられる
4. 要件定義書の理想的な構成への移行パスを確保

**ロードマップ**:

- **現在〜3ヶ月**: 既存API最適化
- **3〜6ヶ月**: サーバーレス簡易API検討
- **6〜12ヶ月**: 必要に応じてフルサーバー実装

### 📝 実装タスク

| タスク                                              | 優先度 | 工数  | 担当 |
| --------------------------------------------------- | ------ | ----- | ---- |
| 現在のAPI仕様をドキュメント化                       | 高     | 1日   | -    |
| `extension-requirements.md`を「理想構成」として更新 | 中     | 0.5日 | -    |
| 段階的移行ロードマップ作成                          | 中     | 1日   | -    |
| ExtensionCatalogContextのパフォーマンス計測         | 低     | 1日   | -    |

**合計工数**: 3.5人日

---

## 不整合4: ExtensionSettingsの二重実装

### 📊 現状分析

**問題**:

- `index.tsx`: upstream互換実装とカスタムマーケットプレイス実装の切り替え
- `ExtensionMarketplaceSettings.tsx`: 独自マーケットプレイス実装
- 現在は`useCustomMarketplace = true`で常にカスタム実装を使用

**コード構造**:

```typescript
// index.tsx
const useCustomMarketplace = true;

if (useCustomMarketplace) {
  return <ExtensionMarketplaceSettings />;
}

// 標準実装（upstream互換）
return (
  <div className={classes.root}>
    <MarketplaceHeader ... />
    <ExtensionList ... />
  </div>
);
```

### 🎯 影響範囲

- ✅ ExtensionsSettings コンポーネント
- ✅ upstream マージ時のコンフリクト
- ⚠️ コードの保守性
- ⚠️ テストの複雑性

### 💡 対応選択肢

#### 選択肢A: カスタム実装への一本化

**概要**: upstream互換実装を削除し、カスタム実装のみに統一

**実装内容**:

1. `index.tsx`から条件分岐を削除
2. `ExtensionMarketplaceSettings`を`index.tsx`に統合
3. upstream互換コードを完全削除

**メリット**:

- ✅ コードがシンプルになる
- ✅ 保守性が向上
- ✅ テストが容易
- ✅ パフォーマンス向上（分岐なし）

**デメリット**:

- ❌ upstream マージが困難
- ❌ 上流の変更を取り込みにくい
- ❌ 独自路線への完全移行

**工数**: 2-3人日

**リスク**: 中（upstreamとの乖離）

---

#### 選択肢B: 現状維持（二重実装継続）（推奨）

**概要**: 現在の二重実装を維持し、upstreamとの互換性を保つ

**実装方針**:

- 条件分岐を維持
- upstream互換コードも継続的に更新
- カスタム実装をデフォルトとして使用

**メリット**:

- ✅ upstream マージが容易
- ✅ 上流の変更を取り込める
- ✅ 必要時に標準実装に戻せる
- ✅ 柔軟性が高い

**デメリット**:

- ❌ コードの複雑性
- ❌ 保守コストが高い
- ❌ テストケースが増える

**工数**: 0人日（追加作業なし）

**リスク**: 低

---

#### 選択肢C: フィーチャーフラグ化

**概要**: 環境変数やユーザー設定で切り替え可能にする

**実装内容**:

```typescript
// 環境変数で制御
const useCustomMarketplace = process.env.ENABLE_CUSTOM_MARKETPLACE !== "false";

// または設定画面で切り替え
const useCustomMarketplace = useAppConfigurationValue<boolean>("enableCustomMarketplace") ?? true;
```

**メリット**:

- ✅ ユーザーが選択可能
- ✅ A/Bテストが可能
- ✅ 段階的なロールアウト
- ✅ フィードバック収集が容易

**デメリット**:

- ⚠️ 実装が複雑化
- ⚠️ 両方の実装を保守する必要
- ⚠️ ユーザーが混乱する可能性

**工数**: 3-4人日

**リスク**: 低〜中

---

### ✅ 推奨対応

**選択肢B: 現状維持（二重実装継続）**

**理由**:

1. upstream との互換性維持が重要
2. 将来的なマージを考慮すると、標準実装の保持が有益
3. 現時点でカスタム実装が安定稼働している
4. リファクタリングのリスクとコストが見合わない

**補足**:

- upstreamが大きく変更された場合は選択肢Aを再検討
- 標準実装も定期的に動作確認を実施

### 📝 実装タスク

| タスク                                 | 優先度 | 工数  | 担当 |
| -------------------------------------- | ------ | ----- | ---- |
| 二重実装の方針をドキュメント化         | 高     | 0.5日 | -    |
| 標準実装の定期動作確認テスト追加       | 中     | 1日   | -    |
| コメント追加（切り替えロジックの説明） | 中     | 0.5日 | -    |

**合計工数**: 2人日

---

## 不整合5: VERSIONタブ機能

### 📊 現状分析

**問題**:

- `phase8-version-tab-implementation-plan.md`: VERSIONタブ追加の計画書が存在
- 実装: 現在はREADME/CHANGELOGタブのみ実装
- Phase 8の完了報告にVERSIONタブ実装が含まれていない

**計画書の内容**:

- 詳細ページにVERSIONタブを追加
- 全バージョンの一覧表示
- バージョン別のインストール機能
- バージョン比較機能

**現在の実装**:

- ExtensionDetails/LayoutDetails: README、CHANGELOGタブのみ
- バージョン情報はカード上のアコーディオンで表示

### 🎯 影響範囲

- ✅ ExtensionDetails コンポーネント
- ✅ LayoutDetails コンポーネント
- ⚠️ ユーザー体験
- ⚠️ ドキュメントの整合性

### 💡 対応選択肢

#### 選択肢A: VERSIONタブ実装（計画書通り）

**概要**: 計画書の仕様に従ってVERSIONタブを実装

**実装内容**:

**1. タブ追加**

```typescript
const tabs = [
  { label: "README", value: "readme" },
  { label: "CHANGELOG", value: "changelog" },
  { label: "VERSIONS", value: "versions" }, // 新規追加
];
```

**2. バージョン一覧表示**

- セマンティックバージョンでソート
- 公開日表示
- インストール状態表示
- 最新バージョンのハイライト

**3. バージョン別アクション**

- 各バージョンのインストールボタン
- バージョン詳細情報の表示
- 変更履歴へのジャンプ

**UI設計**:

```
┌─────────────────────────────────────────────────┐
│ Extension Name                         [×]      │
├─────────────────────────────────────────────────┤
│ [README] [CHANGELOG] [VERSIONS]                 │
├─────────────────────────────────────────────────┤
│ ┌─────────────────────────────────────────────┐ │
│ │ v2.1.0 (Latest) • 2025-09-30  [Installed]  │ │
│ │ What's new in this version...               │ │
│ │                                   [Details] │ │
│ ├─────────────────────────────────────────────┤ │
│ │ v2.0.0 • 2025-09-01           [Install]    │ │
│ │ Major update with breaking changes...       │ │
│ │                                   [Details] │ │
│ ├─────────────────────────────────────────────┤ │
│ │ v1.9.0 • 2025-08-15           [Install]    │ │
│ │ Feature enhancements...                     │ │
│ │                                   [Details] │ │
│ └─────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────┘
```

**メリット**:

- ✅ ユーザー体験の向上
- ✅ バージョン管理が明確
- ✅ 計画書との整合性
- ✅ 旧バージョンへのアクセスが容易

**デメリット**:

- ⚠️ 実装コストがかかる
- ⚠️ タブが増えてUIが複雑化

**工数**: 3-5人日

**リスク**: 低

---

#### 選択肢B: 現状維持（カード上のアコーディオンのみ）（推奨）

**概要**: VERSIONタブは実装せず、カード上のアコーディオンで代替

**実装方針**:

- マーケットプレイス一覧でバージョン管理
- 詳細ページはREADME/CHANGELOGに集中
- 計画書を「将来の拡張」として位置づけ

**メリット**:

- ✅ 追加実装不要
- ✅ UIがシンプル
- ✅ 現在の実装で十分機能している

**デメリット**:

- ❌ 詳細ページでバージョン一覧が見れない
- ❌ 計画書との不整合

**工数**: 0人日（追加作業なし）

**リスク**: 低

---

#### 選択肢C: 簡易バージョン情報表示

**概要**: VERSIONタブではなく、詳細ページに簡易的なバージョン情報を追加

**実装内容**:

- README/CHANGELOGタブの上部にバージョンドロップダウンを追加
- 選択したバージョンのドキュメントを表示
- 専用タブは作らない

**UI設計**:

```
┌─────────────────────────────────────────────────┐
│ Extension Name                         [×]      │
│ Version: [v2.1.0 (Latest) ▼]                   │
├─────────────────────────────────────────────────┤
│ [README] [CHANGELOG]                            │
├─────────────────────────────────────────────────┤
│ (選択したバージョンのドキュメント表示)            │
└─────────────────────────────────────────────────┘
```

**メリット**:

- ✅ 実装コストが低い
- ✅ UIがシンプル
- ✅ バージョン切り替えが容易

**デメリット**:

- ⚠️ 一覧性が低い
- ⚠️ 計画書とは異なる実装

**工数**: 2-3人日

**リスク**: 低

---

### ✅ 推奨対応

**選択肢B: 現状維持（カード上のアコーディオンのみ）**

**理由**:

1. 現在の実装で十分な機能を提供している
2. マーケットプレイス一覧でバージョン管理ができる
3. 詳細ページはドキュメント閲覧に集中すべき
4. 実装コストに対する効果が限定的

**補足**:

- ユーザーフィードバックでバージョン一覧の需要が高い場合、選択肢Aを再検討

### 📝 実装タスク

| タスク                                                                  | 優先度 | 工数  | 担当 |
| ----------------------------------------------------------------------- | ------ | ----- | ---- |
| `phase8-version-tab-implementation-plan.md`を「将来の拡張案」として更新 | 高     | 0.5日 | -    |
| Phase 8完了報告の修正（VERSIONタブは未実装と明記）                      | 高     | 0.5日 | -    |
| ユーザーフィードバック収集（バージョン管理のニーズ）                    | 低     | 1日   | -    |

**合計工数**: 2人日

---

## 不整合6: LayoutDetails実装状況

### 📊 現状分析

**問題**:

- `hybrid-extension-loader-integration-log.md`: LayoutDetails実装完了と記載
- 実際の実装状況が不明瞭
- LayoutDetailsコンポーネントの存在確認が必要

**ドキュメントの記載**:

> "LayoutDetailsコンポーネントを実装し、レイアウト詳細表示機能を完成させました"

### 🎯 影響範囲

- ✅ LayoutMarketplaceSettings
- ✅ レイアウト詳細表示機能
- ⚠️ ドキュメントの信頼性

### 💡 対応選択肢

#### 選択肢A: 実装状況の確認と修正

**概要**: LayoutDetailsコンポーネントの実装状況を確認し、ドキュメントを修正

**調査項目**:

1. LayoutDetailsコンポーネントファイルの存在確認
2. 実装内容の確認
3. ExtensionDetailsとの比較
4. 実際の動作確認

**パターン1: 実装済みの場合**

- ドキュメントは正確なので、そのまま維持
- 動作確認テストを追加

**パターン2: 未実装の場合**

- ドキュメントを修正（「実装完了」→「実装予定」）
- 実装タスクを作成

**パターン3: 部分実装の場合**

- 実装済み機能と未実装機能を明記
- 完成度を記載

**メリット**:

- ✅ 正確な情報に基づく判断
- ✅ ドキュメントの信頼性向上
- ✅ 必要なタスクの明確化

**デメリット**:

- ⚠️ 調査工数がかかる

**工数**: 0.5-1人日（調査）+ α（実装の場合）

**リスク**: 低

---

#### 選択肢B: LayoutDetails実装（未実装の場合）

**概要**: ExtensionDetailsを参考にLayoutDetailsを実装

**実装内容**:

**1. ファイル作成**

- `/packages/suite-base/src/components/LayoutDetails.tsx`

**2. 基本構造**

```typescript
interface LayoutDetailsProps {
  layout: LayoutMarketplaceDetail;
  installed: boolean;
  onClose: () => void;
  onInstall?: () => void;
  onUninstall?: () => void;
}

export default function LayoutDetails({
  layout,
  installed,
  onClose,
  onInstall,
  onUninstall,
}: LayoutDetailsProps): React.ReactElement {
  // ExtensionDetailsと同様の実装
}
```

**3. 機能**

- レイアウト基本情報表示
- README/CHANGELOGタブ
- インストール/アンインストールボタン
- バージョン情報表示

**メリット**:

- ✅ 機能完成度の向上
- ✅ ExtensionDetailsとの一貫性
- ✅ ユーザー体験の向上

**デメリット**:

- ⚠️ 実装コストがかかる（未実装の場合）

**工数**: 3-5人日（未実装の場合）

**リスク**: 低

---

### ✅ 推奨対応

**選択肢A: 実装状況の確認と修正**

**手順**:

1. LayoutDetailsコンポーネントの存在確認
2. 実装内容の確認
3. ドキュメント修正または実装タスク作成

**理由**:

1. 正確な状況把握が最優先
2. 無駄な実装を避ける
3. ドキュメントの信頼性確保

### 📝 実装タスク

| タスク                                | 優先度 | 工数   | 担当 |
| ------------------------------------- | ------ | ------ | ---- |
| LayoutDetailsコンポーネントの存在確認 | 高     | 0.25日 | -    |
| 実装内容の確認と動作テスト            | 高     | 0.5日  | -    |
| ドキュメント修正（必要に応じて）      | 高     | 0.25日 | -    |
| LayoutDetails実装（未実装の場合）     | 中     | 3-5日  | -    |

**合計工数**: 1人日 + α（未実装の場合は+3-5人日）

---

## 不整合7: テスト用サムネイル画像

### 📊 現状分析

**問題**:

- 実装コードで`https://picsum.photos/`を使用したテスト画像を生成
- 本番環境での画像URL仕様が未定義
- テストコードと本番コードの区別が不明確

**現在のコード**:

```typescript
// ExtensionMarketplaceSettings.tsx
const testThumbnail =
  index % 4 === 0 ? `https://picsum.photos/120/120?random=${100 + index}` : undefined;

// LayoutMarketplaceSettings.tsx
const testThumbnail =
  index % 3 === 0 ? `https://picsum.photos/120/120?random=${index}` : layout.thumbnail;
```

### 🎯 影響範囲

- ✅ サムネイル表示機能
- ⚠️ 本番環境での動作
- ⚠️ パフォーマンス
- ⚠️ プライバシー（外部サービス依存）

### 💡 対応選択肢

#### 選択肢A: テストコード削除・本番仕様実装（推奨）

**概要**: テスト用コードを削除し、本番環境用の実装に置き換え

**実装内容**:

**1. サムネイル仕様の決定**

```typescript
interface ExtensionMarketplaceDetail {
  // ... 既存フィールド
  thumbnail?: string; // サムネイルURL（オプション）
  icon?: string; // アイコンURL（オプション）
}
```

**2. フォールバック処理**

```typescript
// thumbnailがない場合の処理
const displayThumbnail = extension.thumbnail ?? undefined;
const displayIcon = extension.icon ?? <ExtensionIcon />;
```

**3. デフォルト画像の提供**

```typescript
// オプション: デフォルト画像を用意
const defaultThumbnail = "/assets/extension-placeholder.png";
const displayThumbnail = extension.thumbnail ?? defaultThumbnail;
```

**メリット**:

- ✅ 本番環境に適した実装
- ✅ テストコードの混入防止
- ✅ パフォーマンス向上（外部依存なし）
- ✅ プライバシー保護

**デメリット**:

- ⚠️ 開発時の視覚的確認が難しくなる

**工数**: 1-2人日

**リスク**: 低

---

#### 選択肢B: 環境別分岐実装

**概要**: 開発環境ではテスト画像、本番環境では実際の画像を使用

**実装内容**:

```typescript
const isDevelopment = process.env.NODE_ENV === "development";

const testThumbnail = isDevelopment
  ? `https://picsum.photos/120/120?random=${100 + index}`
  : undefined;

const displayThumbnail = extension.thumbnail ?? testThumbnail;
```

**メリット**:

- ✅ 開発時の視覚的確認が容易
- ✅ 本番環境では適切な動作
- ✅ 開発効率の向上

**デメリット**:

- ⚠️ 環境による動作の違い
- ⚠️ コードが複雑化

**工数**: 0.5-1人日

**リスク**: 低

---

#### 選択肢C: モック画像の内部提供

**概要**: picsum.photosの代わりに、プロジェクト内でモック画像を提供

**実装内容**:

**1. モック画像の用意**

```
public/
└── mock-images/
    ├── extension-1.png
    ├── extension-2.png
    ├── extension-3.png
    ├── layout-1.png
    ├── layout-2.png
    └── layout-3.png
```

**2. モック画像の使用**

```typescript
const mockImages = [
  "/mock-images/extension-1.png",
  "/mock-images/extension-2.png",
  "/mock-images/extension-3.png",
];

const testThumbnail =
  !extension.thumbnail && isDevelopment
    ? mockImages[index % mockImages.length]
    : extension.thumbnail;
```

**メリット**:

- ✅ 外部依存なし
- ✅ オフライン開発が可能
- ✅ 一貫した表示

**デメリット**:

- ⚠️ 画像ファイルの管理が必要
- ⚠️ リポジトリサイズの増加

**工数**: 1-2人日

**リスク**: 低

---

### ✅ 推奨対応

**選択肢B: 環境別分岐実装**

**理由**:

1. 開発効率を損なわない
2. 本番環境では適切に動作
3. 実装コストが最小
4. 柔軟性が高い

**補足実装**:

- サムネイル仕様のドキュメント化
- extensions.jsonスキーマの明確化
- デフォルト画像の提供（オプション）

### 📝 実装タスク

| タスク                             | 優先度 | 工数  | 担当 |
| ---------------------------------- | ------ | ----- | ---- |
| 環境別分岐コードの実装             | 高     | 0.5日 | -    |
| サムネイル仕様のドキュメント化     | 高     | 0.5日 | -    |
| extensions.jsonスキーマ更新        | 中     | 0.5日 | -    |
| デフォルト画像の作成（オプション） | 低     | 1日   | -    |

**合計工数**: 1.5人日（デフォルト画像含めると2.5人日）

---

## 推奨実装順序

各不整合への対応を優先度順に並べると以下のようになります。

### フェーズ1: 緊急対応（1-2週間）

| 不整合                    | 対応                           | 工数  | 優先度 |
| ------------------------- | ------------------------------ | ----- | ------ |
| 6. LayoutDetails実装状況  | 実装状況確認・ドキュメント修正 | 1日   | 🔴 高  |
| 7. テスト用サムネイル画像 | 環境別分岐実装                 | 1.5日 | 🔴 高  |
| 5. VERSIONタブ機能        | ドキュメント修正               | 2日   | 🟡 中  |

**合計**: 4.5人日

### フェーズ2: 中期対応（1-2ヶ月）

| 不整合                       | 対応                       | 工数  | 優先度 |
| ---------------------------- | -------------------------- | ----- | ------ |
| 1. バージョン管理方式        | ハイブリッド方式改善       | 7-9日 | 🟡 中  |
| 3. マーケットプレイスAPI     | 段階的移行計画策定         | 3.5日 | 🟡 中  |
| 4. ExtensionSettings二重実装 | ドキュメント化・テスト追加 | 2日   | 🟢 低  |

**合計**: 12.5-14.5人日

### フェーズ3: 長期対応（3-6ヶ月）

| 不整合            | 対応           | 工数 | 優先度 |
| ----------------- | -------------- | ---- | ------ |
| 2. 拡張機能ID形式 | ドキュメント化 | 1日  | 🟢 低  |

**合計**: 1人日

---

## まとめ

### 総工数見積もり

- **フェーズ1**: 4.5人日（緊急）
- **フェーズ2**: 12.5-14.5人日（中期）
- **フェーズ3**: 1人日（長期）

**合計**: 18-20人日

### 重要な決定事項

1. **バージョン管理**: ハイブリッド方式を継続し、段階的に改善
2. **拡張機能ID**: 従来形式を継続使用
3. **マーケットプレイスAPI**: 段階的に独立サーバーへ移行
4. **ExtensionSettings**: 二重実装を維持しupstream互換性を保持
5. **VERSIONタブ**: 現状維持、将来の拡張として位置づけ
6. **LayoutDetails**: 実装状況を確認後、適切に対応
7. **サムネイル画像**: 環境別分岐で開発効率と本番品質を両立

### 次のアクション

1. ✅ フェーズ1の緊急対応を実施（1-2週間）
2. 📋 フェーズ2の詳細計画を策定
3. 📋 各ドキュメントの更新
4. 📋 チームレビュー・承認プロセス

---

**参考ドキュメント**:

- [マーケットプレイス機能仕様書](./MARKETPLACE_FEATURES.md)
- [マーケットプレイス目次](./INDEX.md)
- [今後の実装ロードマップ](./planning/future-implementation-roadmap.md)

# IterablePlayer アーキテクチャ仕様書

## 概要

`IterablePlayer` は、Lichtblick Suite において再生可能データソースからのメッセージ再生を管理するコアクラスです。状態マシンパターンを採用し、データソースからの非同期メッセージストリーミング、バッファリング、プリロード機能を提供します。

## 設計原則

### 1. 状態マシンアーキテクチャ

IterablePlayerは以下の状態を持つ有限状態マシンとして実装されています：

```
preinit → initialize → start-play → idle ⇄ play
                                    ↓     ↑
                              seek-backfill ↗
                                    ↓
                           reset-playback-iterator
                                    ↓
                                  close
```

#### 状態の詳細

- **preinit**: 初期化前の状態
- **initialize**: データソースの初期化とメタデータ読み込み
- **start-play**: 初期メッセージの読み込み
- **idle**: 再生停止中、UIからの操作待ち
- **play**: アクティブな再生中
- **seek-backfill**: シーク操作によるバックフィル処理
- **reset-playback-iterator**: サブスクリプション変更によるイテレータリセット
- **close**: 終了処理

### 2. レイヤードアーキテクチャ

```
IterablePlayer
    ↓
BufferedIterableSource / DeserializingIterableSource
    ↓
IIterableSource (実際のデータソース)
```

### 3. コンポーネント分離

- **状態管理**: 状態遷移とライフサイクル管理
- **メッセージ処理**: バッファリング、フィルタリング、配信
- **プリロード管理**: BlockLoaderによるバックグラウンド読み込み
- **再生制御**: 速度、シーク、一時停止機能

## 主要コンポーネント

### 1. 状態管理システム

```typescript
type IterablePlayerState =
  | "preinit"
  | "initialize"
  | "start-play"
  | "idle"
  | "seek-backfill"
  | "play"
  | "close"
  | "reset-playback-iterator";
```

状態遷移は `#setState()` メソッドにより管理され、各状態は協調的に終了して次の状態に移行します。

### 2. メッセージフロー管理

#### バッファリング戦略

- **二重バッファリング**: `BufferedIterableSource` + `BlockLoader`
- **アダプティブローディング**: 再生速度に応じた読み込み量調整
- **メモリ管理**: 最大1GB上限でのキャッシュ管理

#### メッセージ配信

- **ティックベース**: 16ms間隔での定期的な配信
- **時間制約**: 最大300msの読み込み制限
- **バックプレッシャー**: UI応答性を保つための流量制御

### 3. プリロード機能

`BlockLoader` が独立したプロセスでフルサブスクリプションのメッセージを事前読み込み：

- **ブロックベース**: 固定時間単位でのデータ分割
- **バックグラウンド処理**: メイン再生に影響しない並行処理
- **メモリ効率**: LRU戦略による自動エビクション

### 4. 再生制御機能

#### 精密シーク

- **バックフィル**: 指定時刻の最新メッセージを各トピックから取得
- **時間クランピング**: データ範囲内での制約保証
- **中断対応**: AbortController による操作キャンセル

#### 可変速再生

- **リアルタイム調整**: 0.1x〜10x範囲での動的速度変更
- **フレーム安定性**: 滑らかな再生のための時間窓調整
- **バッファリング表示**: 遅延時のユーザーフィードバック

## パフォーマンス最適化

### 1. メモリ管理

- **バッファサイズ制限**: デフォルト1GB、シリアライズド300MB
- **参照等価性保持**: React re-render最小化
- **ガベージコレクション**: 適切なオブジェクト解放

### 2. 非同期処理

- **debouncePromise**: 状態更新の適切な間引き
- **協調的並行性**: yieldによるイベントループ配慮
- **abort対応**: 長時間処理のキャンセル機能

### 3. データ効率性

- **選択的読み込み**: 必要フィールドのみのデシリアライゼーション
- **ブロック化**: 効率的なランダムアクセス
- **圧縮対応**: 複数解凍アルゴリズムサポート

## エラーハンドリング

### 1. 階層的エラー処理

- **PlayerAlertManager**: ユーザー向けエラー表示
- **復旧機能**: 可能な場合の自動回復
- **デグレードモード**: 部分機能での継続動作

### 2. 堅牢性保証

- **入力検証**: 時間範囲やトピック名の妥当性チェック
- **不変条件**: assertによる内部状態検証
- **リソース解放**: finallyブロックによる確実なクリーンアップ

## 拡張性

### 1. プラガブルアーキテクチャ

- **IIterableSource**: 多様なデータソース対応
- **メトリクス収集**: 運用監視機能の組み込み
- **プロファイル対応**: ROS1/ROS2等の形式別最適化

### 2. 設定可能性

- **プリロード制御**: 用途に応じた有効/無効切り替え
- **キャッシュサイズ**: メモリ環境に応じた調整
- **読み込み先行時間**: ネットワーク状況に応じた調整

## 使用例

### 基本的な初期化と再生

```typescript
const player = new IterablePlayer({
  source: myDataSource,
  sourceId: "unique-source-id",
  enablePreload: true,
  readAheadDuration: { sec: 10, nsec: 0 },
});

// リスナー設定
player.setListener(async (state) => {
  // UI更新処理
  updateUI(state);
});

// サブスクリプション設定
player.setSubscriptions([
  { topic: "/sensor/camera", preloadType: "full" },
  { topic: "/sensor/lidar", preloadType: "partial" },
]);

// 再生開始
player.startPlayback();

// シーク
player.seekPlayback({ sec: 100, nsec: 0 });

// 終了
player.close();
```

## パフォーマンスメトリクス

### 主要指標

- **メモリ使用量**: プリロード・バッファ別の使用量追跡
- **読み込み遅延**: ディスクI/O〜UI表示までの時間
- **フレームドロップ**: 目標16ms フレーム時間の達成率
- **バッファリング率**: 再生中断の頻度と継続時間

### 最適化目標

- **低遅延**: シーク操作100ms以内の応答
- **高スループット**: 秒間1000メッセージ以上の処理
- **メモリ効率**: 1時間データで1GB以下のピーク使用量
- **CPU効率**: メイン再生処理でCPU使用率30%以下

## セキュリティ考慮事項

### 1. リソース制限

- **メモリ枯渇防止**: 厳格な上限設定
- **CPU過負荷防止**: 処理時間制限と間引き
- **ファイルアクセス制限**: サンドボックス内での動作

### 2. 入力検証

- **時間値の妥当性**: オーバーフロー・アンダーフロー対策
- **トピック名検証**: インジェクション攻撃防止
- **メッセージサイズ制限**: 異常に大きなメッセージの拒否

この仕様書は IterablePlayer の理解と保守性向上のための参考資料として活用してください。
